RFC                         Chadow                         version 1.0.0
                                                               Mars 2024
                                                         Valentin Sebbah
                                                          Antoine Bastos

DESCRIPTION

  Le protocole Chadow est un protocole d'échange de message et de 
  fichiers. Il permet la mise en place d'un reseau de partage 
  décentralisé de fichiers entre clients. Il embarque un moyen 
  d'éventuellement anonymiser le téléchargement en passant par d'autres
  clients qui servent de proxy.

SOMMAIRE

  1. Conventions. . . . . . . . . . . . . . . . . . . . . . . . . . 1
  2. Encodage. . . . . . . . . . . . . . . . . . . . . . . . . .  . .
  3. Identification. . . . . . . . . . . . . . . . . . . . . . . . .  
  4. Discussion. . . . . . . . . . . . . . . . . . . . . . . . . . .
    4.1 Découverte des utilisateurs. . . . . . . . . . . . . . . . .
    4.2 Mise à jour des présences. . . . . . . . . . . . . . . . . .
    4.3 Publication de message globaux. . . . . . . . . . . . . . . .
    4.4 Echange de message entre utilisateurs. . . . . . . . . . . .
  5. Codex. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  
    5.1 Publication du codex. . . . . . . . . . . . . . . . . . . . .
    5.2 Téléchargement du codex. . . . . . . . . . . . . . . . . . . 
  6. Recherche de partage. . . . . . . . . . . . . . . . . . . . . .
  7. Annonce. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
  8. Téléchargement des fichiers du codex. . . . . . . . . . . . . . .
    8.1 Mode de Téléchargement. . . . . . . . . . . . . . . . . . . .
      8.1.1 Mode ouvert. . . . . . . . . . . . . . . . . . . . . . .
      8.1.2 Mode fermé. . . . . . . . . . . . . . . . . . . . . . . .
  9. Déconnexion. . . . . . . . . . . . . . . . . . . . . . . . . . .




















                                                                [page 1]

1. Conventions

  Il existe des noeuds:
    - serveur, représenté par une lettre majuscule entre crochet, ex:[A]
    - client, représenté par une lettre majuscule, ex: B

                        B ------ [A] ----- C
                                  |
                                  |
                                  D
  
  Chadow utilise le protocole TCP (Transmission Control Protocol) comme 
  fondation pour assurer la fiabilité et l'intégrité des communications 
  entre les clients et le serveur. 

  Codex : Une suite de données décrivant les fichiers partagés par un ou plusieurs 
    utilisateurs dans un réseau pair à pair. Chaque codex est identifié par un identifiant
    unique (ID) et comprend des informations telles que la liste des fichiers partagés, 
    les parties de ces fichiers disponibles chez chaque utilisateur (sharer), 
    et d'autres métadonnées pertinentes.

  Annuaire : Un serveur centralisé qui stocke une liste de codex disponibles dans le réseau. 
    L'annuaire permet à tout client de récupérer les informations nécessaires sur les codex 
    afin de participer au partage de fichiers. En consultant l'annuaire, un client peut découvrir 
    quels fichiers sont disponibles pour le téléchargement, ainsi que les utilisateurs (sharers) 
    qui possèdent des parties de ces fichiers.

  Client : Une application logicielle utilisée pour télécharger et partager des fichiers dans un 
    réseau pair à pair. Les clients interagissent avec l'annuaire pour obtenir des informations sur 
    les fichiers disponibles et établissent des connexions avec d'autres utilisateurs (sharers) pour 
    échanger des parties de fichiers.

  Sharer : Dans le contexte d'un réseau de partage de fichiers pair à pair, les sharers sont les 
    utilisateurs qui possèdent et partagent des parties de fichiers avec d'autres utilisateurs. 
    Chaque sharer contribue au réseau en mettant à disposition des parties de fichiers qu'il possède, 
    permettant ainsi aux autres utilisateurs de télécharger ces fichiers à partir de plusieurs sources.


2. Encodage

  Opcode des trames
  +-----------------------+-----------------------+
  | 0  | error            | 1  | register         |
  +-----------------------+-----------------------+
  | 2  | discovery        | 3  | event            |
  +-----------------------+-----------------------+
  | 4  | yell             | 5  | whisper          |
  +-----------------------+-----------------------+
  | 6  | propose          | 7  | request          |
  +-----------------------+-----------------------+
  | 8  | announce         | 9  | update           |
  +-----------------------+-----------------------+
  | 10 | request          | 11 | handshake        |
  +-----------------------+-----------------------+
  | 12 | keepalive        | 13 | choke            |
  +-----------------------+-----------------------+
  | 14 | unchoke          | 15 | interested       |
  +-----------------------+-----------------------+
  | 16 | notinterested    | 17 | have             |
  +-----------------------+-----------------------+
  | 18 | needblock        | 19 | cancel           |
  +-----------------------+-----------------------+
  | 20 | hereblock        | 21 | proxyopen        |
  +-----------------------+-----------------------+

  [page 2]
                                                                
  - un int représente 4 octets
  - un long représente 8 octets
  - une string est toujours précédée par sa taille en int (4 octets) 

                  +--------------------------------+
                  | size (int) | mystring (string) | 
                  +--------------------------------+

  - 'creation_date' est une date au format UNIX (long), 
  nombre de secondes depuis le 1er janvier 1970 à 00:00:00 UTC

  - 'username' et 'username_receiver' se réfèrent à une chaine de 
    charactères (string):
    - D'une taille comprise entre 2 et 32 charactères
    - Encodée en UTF-16 (Unicode)
    - Ne contenant pas d'espaces ou de charactères invisibles
    - Ne contenant pas les sous-chaînes suivantes : @, #, :, /, 
    ```, chadow
    Le serveur doit garantir qu'il n'existe pas deux clients avec le 
    même username.


3. Identification

  Le client doit connaître l'adresse du serveur avec lequel il 
  souhaite communiquer.
  Lorsqu'un client souhaite se connecter au serveur IRC, il envoie une 
  demande de connexion en spécifiant le nom d'utilisateur qu'il souhaite 
  utiliser. Voici le format de la trame pour cette demande : 

                    +-----------------------+
                    | (register) | username | 
                    +-----------------------+
                    
  Le serveur répond au client pour indiquer si le nom d'utilisateur est 
  disponible ou non :
    - Si le nom d'utilisateur est disponible, le serveur envoie une 
    validation au client :
      
                    +-----------------------+
                    | (register) | username | 
                    +-----------------------+
  
    - Si le nom d'utilisateur est déjà utilisé, le serveur envoie un 
    message d'erreur au client :
      
          +--------------------------------------------+
          | (error) | username already in use (string) | 
          +--------------------------------------------+
      
      Dans ce cas ci le client peut envoyer à nouveau une demande de 
      connexion au serveur.
      
   
4. Discussion

4.1 Découverte des utilisateurs 
  Le client envoie au serveur la trame suivante:

  +-------------+
  | (discovery) |
  +-------------+
              
  Le serveur répond avec la liste des noms d'utilisateurs présents:

  +-------------------------+
  | (discovery) | usernames |
  +-------------------------+

  usernames: 
    liste des usernames des clients connectés. Concaténation des sharers 
    <taille de l'username en int><username>.
    La liste se termine par 0.
    Ex: 8morpheus7trinity0
              
4.2 Mise à jour des présences

  Le serveur notifie les évènements ('code') d'arrivé (1) et de départ 
  (0) à tous les clients. Permet d'éviter de demander la liste entière 
  des utilisateurs systématiquement.
  Finalement les arrivés et départs sont traités comme des messages globaux.

  +------------------------------+
  | (event) | code |  username   |
  +------------------------------+

  username: le username associé avec l'évènement

4.3 Publication de messages globaux

  Le client envoie une trame de publication de message global.

  +-------------------------------------------+
  | (yell) | creation_date | message (string) |
  +-------------------------------------------+

  Le serveur retransmet la même trame à tous les clients même le 
  client d'origine.

4.4 Echange de messages entre utilisateurs

  Le client envoie au serveur une trame pour un message privé destiné 
  à un username spécifique. 

  +------------------------------------------------------------------+
  | (whisper) | username_receiver | creation_date | message (string) |
  +------------------------------------------------------------------+

  Le serveur la retransmet au client associé.

  Si le serveur ne connaît pas l'username (n'est plus connecté ou 
  n'existe pas), le serveur réponds une trame d'erreur.

  +---------------------------------+
  | (error) | unknown user (string) |
  +---------------------------------+


5. Codex
  L'annuaire possède des descriptions de chaque partage qu'on appelle codex.
  L'annuaire sait quels clients partage un codex. 
  Les clients peuvent chercher des codex dans l'annuaire.
  Les clients peuvent demander à l'annuaire de rejoindre le réseau de partage 
  des fichiers du codex.

5.1 Publication du codex
  
  L'intérêt est que le l'annuaire ne possède pas de copie des fichiers en partage, 
  ce qui reviendrait à du téléchargement centralisé et nécessite un serveur très puissant.
  L'annuaire possède seulement un description des fichiers que les sharers partagent.

  Le client peut proposer un ou des fichiers au partage qui sont rassemblés dans 
  un même ensemble décrit pas le codex. 
  
  +------------------------------+
  | (propose) | codex_id | codex |
  +------------------------------+

  codex_id : le hachage (SHA1) du codex.
  codex : une structure comprenant les informations suivantes :
    - name : le nom du codex (string).
    - chunk_length : la taille fixe des chunks du codex.
    - files_count : le nombre de fichiers (int).
    - chunks : la concaténation des identifiants SHA1 (20 octets) de chaque chunk.
  
    Chaque fichier du codex est découpé en chunk d'une taille fixe en int, 
    d'une puissance 2. De cette façon plusieurs sharers peuvent partager
    des bouts du fichiers en simultané, ce qui augmente sa disponibilité 
    et la probabilité qu'un client aboutisse à compléter le téléchargement.
    Dans un optique de pouvoir télécharger des fichiers d'une taille jusqu'à 2Go
    on propose une taille de 256ko qui donne un total de 7 813 chunks.
    Chaque chunk est ensuite hashé pour obtenir un identifiant SHA1.
    Pour un fichier de 2Go cette liste de sha1 (20 bytes) réprésente un poids de 156ko, ce qui est raisonnable.
    Le hashage permet aux clients de s'assurer de l'intégrité des données qu'il télécharge, 
    en testant le hash du chunk reçu avec celui décrit dans le codex. 

  files: 
    une liste qui concatène tous les <nomfichier><path> des fichiers du 
    codex. nomfichier et path sont des strings. 
    path représente le chemin absolu où nomfichier se situe dans le codex.
  

5.2 Téléchargement du codex

  Le client peut télécharger le codex avec la trame: 

  +----------------------+
  | (request) | codex_id |
  +----------------------+

  codex_id: hash (SHA1) du codex

  Le serveur répond avec la trame suivante :

  +-------------------+
  | (request) | codex |
  +-------------------+

  où codex contient les mêmes informations que décrites dans la partie 5.1.


6. Recherche de codex

  Le client envoie une trame de recherche au serveur avec les informations suivantes :

  +--------------------------------------------------------------------+
  | (search) | codex_name | options | expected_results | creation_date |
  +--------------------------------------------------------------------+
    
  codex_name : (string) le nom du codex à rechercher.
  options : un champ de bits (int) où chaque bit est numéroté à partir du poids fort.
    - Le bit 1 indique une recherche à une date spécifique (incluse).
    - Le bit 2 indique une recherche avant une certaine date (exclue).
    - Le bit 3 indique une recherche après une certaine date (exclue).
  expected_results : (int) le nombre de résultats attendus, avec 0 pour "tous".
  
  exemple de trame pour le client qui recherche le codex "MonCodex": 
  +--------------------------------------------------------------------+
  | (search) | MonCodex | 2       | 5                 | 1646232387     |
  +--------------------------------------------------------------------+

  
  Le serveur répond avec les informations suivantes :

  +----------------------------------------+
  | (search) | number_of_results | results |
  +----------------------------------------+

  number_of_results : (int) le nombre total de résultats.
  results : une liste comprenant :
    - filename : (string) le nom du fichier.
    - info_hash : (20 bytes) le hash d'information.
    - creation_date : (long) la date de création.
    - seeders : (int) le nombre de seeders (sharers partageant le fichier).
    - leechers : (int) le nombre de leechers (clients téléchargeant le fichier).


7. Annonce

  Le client annonce à intervalle régulier (définit par le serveur) 
  l'état dans lequel il se trouve pour chaque fichier qu'il partage et 
  ou télécharge.

  +-------------------------------------+
  | (announce) | info_hash | parameters |
  +-------------------------------------+

  info_hash: (SHA1) hash du dictionnaire de données associé au partage
  paramètres: une liste comprenant :
    event: (byte)
      - 0 : indique que le client est en train de télécharger le fichier.
      - 1 : signifie que le client a cessé de partager le fichier.
      - 2 : indique que le client a complètement téléchargé le fichier.
      Ce paramètre spécifie l'état actuel du fichier.
    privacy: (byte)
      - 0 : signifie que le partage est en mode caché.
      - 1 : indique que le partage est en mode ouvert.
      Ce paramètre détermine la visibilité du partage.
    sharers: 
      (int) le nombre de sharers que le client souhaite recevoir 
      du serveur pour garantir le téléchargement du fichier.
    proxy: 
      (int) le nombre de clients que le client accepte de servir 
      en tant que relais pour leurs téléchargements.


  Le serveur répond avec une trame pour répondre à la requête :

  +---------------------------------------------------------------------------+
  | (announce) | info_hash | complete | imcomplete | wait | sharers | proxies |
  +---------------------------------------------------------------------------+

  complete: le nombre de sharers ayant le fichier complet (int)
  incomplete: le nombre de clients téléchargeant le fichier (int)
  wait: l'intervalle minimum que le client doit attendre avant de refaire une annonce (int)
  sharers: une liste de sharers actifs au partage du codex, chaque sharer étant 
           représenté par une série de 6 octets d'informations:

    +---------------------------------------------+
    | sharers_count | ip | port | ip | port | ... |
    +---------------------------------------------+

    - sharers_count: le nombre de sharers actifs (int)
    - ip: l'adresse IP du sharer (4 octets)
    - port: le port du sharer (2 octets)

  proxies: présent lorsque le client télécharge en mode fermé. 
    Liste des clients disponibles pour agir en tant que proxy :

    +---------------------------------------------+
    | proxies_count | ip | port | ip | port | ... |
    +---------------------------------------------+

    - proxies_count: le nombre de pairs disponibles pour agir en tant que proxy (int)
    - ip: l'adresse IP du client (4 octets)
    - port: le port du client (2 octets)

  En cas d'erreur, le serveur répond avec la trame suivante : 

  +----------------------------------+
  | (error) | error_message (string) |
  +----------------------------------+

8. Téléchargement des fichiers du torrent  
8.1 Mode ouvert - version BitTorrent
  Implémentation du sharer wire protocol sur TCP

  A ce stade le client possède un fichier torrent/metainfo et donc 
  connaît la liste des pièces du torrent et les fichiers qu'il contient.
  Il connaît également les pairs qu'il doit contacter pour récupérer les 
  pièces.

  Le client initie l'échange avec un pair avec le handshake:

  +-------------------------+
  | (handshake) | codex_id  | 
  +-------------------------+

  Si le client reçoit un handshake avec un codex_id qu'il ne possède 
  pas où qu'il ne souhaite pas partager il peut terminer la connexion.

  Le reste des trames échangées est préfixées par leur taille, afin de
  facilter la lecture sur le socket par le client.

  Champs de bits

  juste après le handshake le client et le pair s'envoient 
  respectivement le champs de bits des chunk qu'ils possèdent du 
  torrent.
  Le bit de poids fort est la pièce d'indice 0.
  Le client termine la connexion si le champs de bits n'est pas de la 
  bonne taille.

  +-------------------------------------+
  | (have) | bitfield_length | bitfield |
  +-------------------------------------+ 


  Le client peut indiquer au pair qu'il vient de compléter un chunk.
   
  +--------------------------+
  | (newchunk) | chunk_index | 
  +--------------------------+

  
  Keep-alive

  Le client doit aussi maintenir la connexion avec des message 
  keep-alive, dans le cas contraire le pair peut y mettre fin s'il 
  n'a rien reçu du client pendant une certaine durée.

  +-------------+
  | (keepalive) | 
  +-------------+
  
  Choke/Unchoke

  Le client tient à jour des informations sur les connexion qu'il 
  a avec les pairs. L'intérêt est de pouvoir équilibrer le partage
  en limitant le nombre de connexion actives et de limiter la 
  saturation du réseau, tout en s'assurant que chaque pairs 
  obtiennent les pièces manquantes le plus rapidement possible.

                                                      Valeur initiale
  am_choking:      le client refuse de servir le pair,         1
  am_interested:   le client est intéressé par le pair,        0
  sharer_choking:    le pair refuse de servir le client,         1
  sharer_interested: le pair est intéressé par le client,        0

  Un block de données est téléchargé quand le client et interested 
  et que le pair n'est pas choke.

  La trame choke/unchoke contient selement le opcode:
  (choke), (unchoke), (interested), (notinterested)

  +---------+
  | (choke) | 
  +---------+



  Demande de block
  Le client souhaite télécharger une pièce au pair.
  le client ne télécharge pas les pièces une à une mais par portions 
  de pièces appelé 'blocks' de taille comprise entre 16ko et la 
  taille de la pièce.

  +------------------------------------------------+
  | (needblock) | piece_index | offset | length   |
  +------------------------------------------------+

  piece_index: l'indice de la piece demandée
  offset:      position en byte du block dans la pièce.
  length:      la taille du block 
  
  Annulation
  Le client peut envoyer une trame pour annuler la requête 
  (need_block) d'un block. La trame est identique à celle envoyée 
  pour la requête mais l'opcode est remplacé par (cancel).

  Envoie du block
  
  Le client répond à une requête de block:

  +----------------------------------------------+
  | (hereblock) | piece_index | offset | payload |
  +----------------------------------------------+ 

  piece_index: l'indice de la piece demandée
  offset:      position en byte du block dans la pièce.
  payload:     la donnée

8.2 Mode fermé

  A ce stade le client possède un fichier torrent/metainfo et donc 
  connaît la liste des pièces du torrent et les fichiers qu'il contient.
  Il connaît également les pairs qui doit contacter pour récupérer les 
  pièces. Il connaît aussi l'adresse des clients qui peuvent 
  potentiellement accepter de faire proxy pour lui.

  Le client demande l'ouverture d'une connexion. 
  Si le pair proxy accepte alors la connection reste ouverte 
  et ouvre une connection avec le pair et le flux est transmis
  dans les deux sens entre le client et le pair. 
  Le reste du fonctionnement du partage est identique au mode ouvert 
  mais passe désormait par le proxy.
                              ___
                  A ---------|   |--------- B
                             | D |          |
                  C ---------|___|--------- +

  Si une des connexion est fermée, côté client ou côté pair alors le 
  la connection restante est fermée.
  Le proxy peut à tout décider moment de terminer son rôle de proxy, 
  et terminer les deux connexions.  

  TODO: rajouter des infos dans les trames A --> | D |
  pour que le client puisse télécharger chez plusieurs pairs
  avec le même proxy sans avoir à ouvrir plusieurs connexions 
  avec le proxy.


  +------------------------------------+
  | (proxy_open) | sharer_ip | sharer_port |     
  +------------------------------------+

  Dans cette implémentation, chaque demande d'ouverture de connexion
  à un proxy par un client ouvre une nouvelle connexion. Le proxy doit 
  gérer sa charge et sa bande passante.

  Il est suggéré au développeur du client de ne pas mettre en place, 
  ou du moins cacher l'option, permettant de choisir ou non d'être 
  proxy. L'utilisateur serait tenté de ne pas l'activer dans le but
  de faciliter le téléchargement de ses propres fichiers, mettant en 
  péril cette fonctionnalité anonymisante du protocole. 

  

9. Deconnexion
  Lorsqu'un client se déconnecte du serveur, que ce soit de manière 
  inattendue ou volontaire, le protocole TCP permet au serveur de 
  détecter automatiquement cette déconnexion. Le serveur réagit à cette 
  déconnexion en libérant les ressources associées à cet utilisateur et 
  en informant tous les autres utilisateurs de sa déconnexion, 
  conformément aux spécifications de la partie "Discussion - Mise à jour 
  des présences".






























                                                                [page 9]
